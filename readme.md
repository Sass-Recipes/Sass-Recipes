#Preface

Pre-processors are on the rise and no one can argue that. First there was HAML and you can't say that HTML didn't need a face-lift. On the other end of this spectrium now is CoffeeScript. While there is some controversy, JavaScript is already in the developer's domain so it is more a matter of adoption by developers that is the issue more then anything. 

Sandwiched in the middle of all of this is an awesome language called Sass. Created by [Hampton Catlin](http://www.hamptoncatlin.com/), he and [Nathan Weizenbaum](http://nex-3.com/) designed this unsung masterpeice through version 2.0. In 2008 [Chris Eppstein](http://chriseppstein.github.com/) joined the Sass team and continues to work with Nathan on evolving the language. 

Sass has somewhat been surrounded by controversy regarding the use of this language. Mainly, I believe, because it crosses domains. There are developers that use CSS and there are designers that use CSS. While most developers will welcome this change, others see CSS as something that has to be done rather than something they want to do. Some designers who love to write CSS, are not confortable with the baggage that Sass comes with. CSS users have come to respect the simplicity of the language that has served to many and see this as an invasion. Even I, when I was first introduced to Sass, stated in an eamil to a colleague, "Why the hell can't developers leave shit alone?" 

But again, my opinion, much of this resistance comes from fear. Fear that is derived from uncertainty and doubt. Uncertain that this is a necessary evolution of the language and doubt that this will address any issues, if not create more. I agree, Sass is a titanic shift in thinking about CSS, but let's face it, CSS is a language that in the face of modern web development just doesn't hold up any longer. Many have come up with, I admit, very cleaver ways of managing their CSS. Naming conventions and organizational techniques that try to bring some sanity to an insane world. But they all fall short in one way or another. Using a *technique* that requires all users are on the same page at all times will fall short when someone isn't minding the store.  

In thie end, isn't every language we code some kind of pre-processor? When is the last time you wrote [machine code](http://en.wikipedia.org/wiki/Machine_code)? That's why I see Sass as a natural extension CSS for the creation and management of modern UIs. So to help dispel the FUD I have volunteered countless hours into raising the awewareness of Sass. And to help bring new users quickly into the fold of Sass and why I bring you *Sass Recipes*. Enjoy.

##Who's this book for?
If you have ever written CSS, this book is for you. Whether or not you are a passionate CSS coder I am assuming that Sass has peeked  your interest at one time or another, or why are you reading this book? 

*Sass Recipes* is for those who are not looking to learn all the nuts and bolts of Sass, but need to solve a problem and see Sass as the solution. Basically, have issue > need solution. Real world problems that require real world and quick solutions. Nevermind the 'how-to engineer from scratch', but here is some code that you can probably use in your project today. 

##What you need
###Sass
Since this is a book on Sass, of course we will need this to be installed one way or another on your computer. There is a wide variety of desktop apps that will process Sass for you. These options will be explored in greater detail in some recipes. 

###Shell
While having access to a command-line prompt isn't necessary, in some cases it is pretty helpful. To what degree makes sense, we will provide solutions that make sense with and without a command-line prompt. For Windows users, you? will use the Command Prompt. OSX or Linux, us the Terminal app.

###Ruby / Sinatra
Sass and Ruby are pretty close, so it is conceivable that in some cases it would eerier to explore some examples in a Ruby environment. To keep things simple, some examples are using Sinatra. A DSL for quickly creating web applications in Ruby with minimal effort. Using Ruby conventions, Gems, .rvmrc files, etc ... these recipes will be easy to clone and quickly get up and running. 

##Labor of love
As you can see, this book is a collection of tips and tricks that I have picked up over time. I hope you enjoy and moreover benefit from the recipes within. Happy coding. 























